#!/usr/bin/python

import json
import os
import os.path
import re
import subprocess
import sys


def exit_usage():
    sys.stderr.write('bad arguments: ' + ' '.join(sys.argv) + '\n')
    sys.exit(2)


def cmd_output(cmd):
    try:
        return subprocess.check_output(cmd, stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as e:
        print 'Error in command: %s' % (' '.join(cmd),)
        sys.stdout.write(e.output)
        sys.exit(e.returncode)


def unchecked_output(cmd):
    try:
        return subprocess.check_output(cmd)
    except subprocess.CalledProcessError as e:
        return e.output


def child_branches(branch):
    # type: (str) -> List[str]
    config_name_text = unchecked_output(
        ['git', 'config', '--name-only',
         '--get-regexp', r'branch\..*\.merge',
         'refs/heads/%s' % (branch,)])
    return re.findall('^branch\.(.*)\.merge$', config_name_text, re.M)


def is_atop(upstream, branch):
    # type: (str) -> bool
    '''True just if `branch` is on top of `upstream`.'''
    return '0' == cmd_output(
        ['git', 'rev-list', '--count', '--max-count=1',
         upstream, '--not', branch,
         '--']).strip()


def munge_resolve_message(text):
    '''If the `git rebase` how-to-resolve message appears in `text`, correct it.'''
    return re.sub(
        '(?<=")git rebase(?= --(?:continue|skip|abort)")',
        'git rb',
        text)


def one_rebase(upstream, branch):
    # More complex than `cmd_output`, in order to munge the merge-conflict
    # instructions.  Which go to stdout in a plain (`type=am`) or
    # `type=merge` rebase, but to stderr in a `type=interactive` rebase,
    # so cover both.
    proc = subprocess.Popen(
        ['git', 'rebase', upstream, branch],
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = proc.communicate()
    retcode = proc.poll()
    if retcode:
        sys.stdout.write(munge_resolve_message(out))
        sys.stderr.write(munge_resolve_message(err))
        sys.exit(retcode)


# Logically what we're doing here is
#
#   rebase_many_simple () {
#       git rebase "$1" "$2"
#       for child in $(child_branches "$2"); do
#           rebase_many_simple "$2" "$child"
#       done
#   }
#
#   rebase_many_full () {
#       for child in $(child_branches "$2"); do
#           rebase_many_full "$2" "$child"
#       done
#       if ! is_atop "$1" "$2"; then
#           rebase_many_simple "$1" "$2"
#       fi
#   }
#
# It gets more complicated than that in order to support --continue
# and friends.  Effectively we maintain the stack of recursive calls
# to these two logical functions, but in "$state_dir" rather than just
# in the running shell, so that we can pick it back up smoothly after
# a rebase hits a conflict and the user re-enters here with --continue
# etc.
#
# In the logical code above, the one line where we can exit and invite
# the user to resume is the `git rebase` call.  So the stack we need
# to represent on disk consists of frames
#    full_0 full_1 ... full_n simple_0 ... simple_m
# where the innermost frame simple_m is at the rebase; the innermost
# rebase_many_full frame full_n is at the rebase_many_simple call; and the
# other frames are each at the recursion inside their respective loops.
#
# Internally, it's convenient to overload the stack data structures
# slightly to represent two variant forms of stack:
#   1. at the top of the `rebase_many_simple` loop, and
#   2. at the top of the `rebase_many_full` loop.
# These don't appear in stacks stored on disk.
#
class RebaseManyMachine(object):
    state_dir = None  # type: str

    orig_branch = None  # type: str
    orig_upstream = None  # type: str
    verbose = False
    dry_run = False

    # The logical stack (see above) is represented by current_rebase,
    # stack_simple, and stack_full.  Three variants:
    #
    #   Variant 0: inside a rebase
    #     current_rebase not None.
    #     simple_m described by current_rebase, full_n omitted as a tail call.
    #
    #   Variant 1: top of `rebase_many_simple` loop.
    #     current_rebase None, stack_simple nonempty.
    #     simple_m included in stack_simple, full_n omitted as a tail call.
    #
    #   Variant 2: top of `rebase_many_full` loop.
    #     current_rebase None, stack_simple empty.
    #     full_n included in stack_full.

    # For Variant 0, the inmost logical frame simple_m, consisting of
    # upstream and branch for the current rebase; else None.
    current_rebase = None  # type: Optional[Tuple[str, str]]

    # The stack of logical frames full_0 ... full_(n-1) (or full_n),
    # each with upstream, branch, and a list of remaining child
    # branches.
    stack_full = []  # type: List[Tuple[str, str, List[str]]]

    # The stack of logical frames simple_0 ... simple_(m-1) (or
    # simple_m), each with branch and a list of remaining child
    # branches.
    stack_simple = []  # type: List[Tuple[str, List[str]]]

    def __init__(self, git_dir):
        # type: (str) -> None
        self.state_dir = os.path.join(git_dir, 'rebase-many')

        self.orig_branch = self.read_state_file('branch')
        self.orig_upstream = self.read_state_file('upstream')
        self.verbose = bool(self.read_state_file('verbose'))
        self.dry_run = bool(self.read_state_file('dry-run'))

    def state_filename(self, basename):
        # type: (str) -> str
        return os.path.join(self.state_dir, basename)

    def read_state_file(self, name):
        # type: (str) -> str
        with file(self.state_filename(name)) as f:
            return f.read().strip()

    def v_out(self, message):
        # type: (str) -> None
        if self.verbose:
            sys.stderr.write(message + '\n')

    def read_stack(self):
        # type: (str) -> None
        with file(self.state_filename('stack')) as f:
            stack_data = json.load(f)
        self.stack_full = stack_data['stack_full']
        self.stack_simple = stack_data['stack_simple']
        self.current_rebase = stack_data['current_rebase']

    def write_stack(self):
        # type: () -> None
        stack_data = {
            'stack_full': self.stack_full,
            'stack_simple': self.stack_simple,
            'current_rebase': self.current_rebase,
        }
        with file(self.state_filename('stack'), 'w') as f:
            json.dump(stack_data, f)

    def write_rebase_log(self, branch):
        # type: (str) -> None
        ref = cmd_output(
            ['git', 'rev-parse', '--symbolic-full-name', branch]).strip()
        current_commit_id = cmd_output(
            ['git', 'rev-parse', '--verify', branch]).strip()
        with file(self.state_filename('rebase-log'), 'a') as f:
            f.write('%s %s\n' % (ref, current_commit_id))

    def return_to_original_branch(self):
        # type: () -> None
        cmd_output(
            ['git', 'checkout', '--quiet', self.orig_branch])

    def reset_all(self):
        # type: () -> None
        log = self.read_state_file('rebase-log')
        for line in reversed(log.split('\n')):
            ref, commit_id = line.rsplit(' ', 1)
            self.v_out('Resetting: %s %s' % (ref, commit_id))
            cmd_output(
                ['git', 'update-ref', '-m', 'rebase-many: aborting', ref, commit_id])
        self.return_to_original_branch()

    def run(self):
        # type: () -> None
        while True:
            #self.v_out(repr(
            #    (self.current_rebase, self.stack_simple, self.stack_full)))

            if self.current_rebase is not None:
                # Variant 0.  Top of a `simple` call, at the rebase.
                upstream, branch = self.current_rebase

                # Attempt rebase.
                self.v_out('Rebasing: %s <- %s' % (upstream, branch))
                if not self.dry_run:
                    self.write_stack()
                    self.write_rebase_log(branch)
                    one_rebase(upstream, branch)

                # If we made it here, proceed to the loop.
                self.current_rebase = None
                self.stack_simple.append((branch, child_branches(branch)))

            elif self.stack_simple:
                # Variant 1.  Top of the `simple` loop.
                branch, children = self.stack_simple[-1]
                if children:
                    # Loop in `rebase_many_simple` not done yet.  Recurse.
                    child = children.pop()
                    self.current_rebase = (branch, child)
                else:
                    # Loop in `rebase_many_simple` done; frame returns.
                    self.stack_simple.pop()

            elif self.stack_full:
                # Variant 2.  Top of the `full` loop.
                upstream, branch, children = self.stack_full[-1]
                if children:
                    # Loop not done yet.  Recurse.
                    child = children.pop()
                    self.stack_full.append((branch, child, child_branches(child)))
                else:
                    # Loop done.
                    if not is_atop(upstream, branch):
                        self.stack_full.pop()
                        self.current_rebase = (upstream, branch)
                    else:
                        # Whole frame done.
                        self.stack_full.pop()

            else:
                # Like Variant 2, but our whole outermost frame is done.
                break

        self.return_to_original_branch()

    def init_stack(self):
        # type: () -> None
        # Stack variant 2.
        self.current_rebase = None
        self.stack_simple = []
        self.stack_full = [
            (self.orig_upstream, self.orig_branch, child_branches(self.orig_branch))]

    def start(self):
        # type: () -> None
        self.init_stack()
        self.run()

    def resume(self, cmd):
        # type: (str) -> None
        assert cmd in ('continue', 'skip')

        self.read_stack()
        assert self.current_rebase  # TODO better error message
        # Variant 0 stack.

        # Resume the rebase.
        cmd_output(['git', 'rebase', '--'+cmd])  # TODO handle errors here

        # If that worked, proceed to the loop with a Variant 1 stack,
        # just like in run().
        upstream, branch = self.current_rebase
        self.current_rebase = None
        self.stack_simple.append((branch, child_branches(branch)))
        self.run()

    def abort(self):
        # type: () -> None
        self.read_stack()
        assert self.current_rebase
        cmd_output(['git', 'rebase', '--abort'])
        self.reset_all()


def main():
    if len(sys.argv) != 2:
        exit_usage()
    cmd = sys.argv[1]

    machine = RebaseManyMachine(os.environ['GIT_DIR'])
    if cmd == 'init':
        machine.start()
    elif cmd in ('continue', 'skip'):
        machine.resume(cmd)
    elif cmd == 'abort':
        machine.abort()
    else:
        exit_usage()


if __name__ == '__main__':
    main()
