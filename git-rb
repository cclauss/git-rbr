#!/bin/sh

SUBDIRECTORY_OK=Yes
OPTIONS_KEEPDASHDASH=
OPTIONS_STUCKLONG=t
OPTIONS_SPEC="\
git rb [options]
--
 Available options are
v,verbose!         print more information
dry-run!           only simulate, don't actually rebase
 Actions:
continue!          continue
abort!             abort
skip!              do \`git rebase --skip\` and continue
"

. git-sh-setup
require_work_tree_exists
cd_to_toplevel

state_dir="$GIT_DIR"/rebase-many

#
# Parse args
#

action=
dry_run=
verbose=

total_argc=$#
while test $# != 0
do
	case "$1" in
	--continue|--abort|--skip)
		test $total_argc -eq 2 || usage
		action=${1#--}
		;;
	--dry-run)
		dry_run=t
		;;
	--verbose)
		verbose=t
		GIT_QUIET=
		;;
	--)
		shift
		break
		;;
	esac
	shift
done
test $# -le 0 || usage

in_progress=
if test -d "$state_dir"
then
	in_progress=t
fi

# TODO detect non-many rebase too

if test -n "$action" && test -z "$in_progress"
then
	die "No rebase-many in progress?"
fi

if test -z "$action" && test -n "$in_progress"
then
	die "\
Rebase-many in progress; try abort/continue, or wipe the state dir.

TODO better message."
fi

#
# Basic helpers
#

verbose () {
	case "$verbose" in
	'')
		;;
	*)
		"$@"
		;;
	esac
}

output () {
	case "$verbose" in
	'')
		output=$("$@" 2>&1 )
		status=$?
		test $status != 0 && printf "%s\n" "$output"
		return $status
		;;
	*)
		"$@"
		;;
	esac
}

#
# Main work
#

get_upstream () {
	git rev-parse --abbrev-ref "$1"@{u}
}

list_child_branches () {
	local branch="$1"
	git config --name-only --get-regexp 'branch\..*\.merge' refs/heads/"$branch" \
		| sed 's/^branch\.\(.*\)\.merge/\1/'
	# XXX Really to get this logic right, I should also check that branch.$child.remote is '.' ...
	# which rapidly makes it sad to be writing in shell.
}

is_atop () {
	local upstream="$1"
	local branch="$2"
	test "$upstream" = "$(git merge-base "$upstream" "$branch")"
}

rebase_one () {
	local upstream="$1"
	local branch="$2"

	# TODO handle continue/etc
	if test -z "$dry_run"
	then
		verbose echo "Rebasing: $upstream <- $branch"
		git rebase "$upstream" "$branch"
	else
		echo "Rebasing: $upstream <- $branch"
	fi
}

# Pre: All descendants of $branch are on their upstreams.
# Post: $branch and all its descendants are on their upstreams.
rebase_many_simple () {
	local upstream="$1"
	local branch="$2"

	verbose echo "Simple: ($upstream) $branch"

	rebase_one "$upstream" "$branch"

	for child in $(list_child_branches "$branch")
	do
		rebase_many_simple "$branch" "$child"
	done
}

# Post: $branch and all its descendants are on their upstreams.
rebase_many_full () {
	local upstream="$1"
	local branch="$2"

	verbose echo "Full: ($upstream) $branch"

	for child in $(list_child_branches "$branch")
	do
		rebase_many_full "$branch" "$child"
	done

	if ! is_atop "$upstream" "$branch"
	then
		rebase_many_simple "$upstream" "$branch"
	fi
}

#
# Handle in-progress rebase, and abort/continue/etc
#

case "$action" in
continue)
	die "TODO implement"
	;;
skip)
	die "TODO implement"
	;;
abort)
	die "TODO implement"
	;;
esac

#
# Handle 
#

require_clean_work_tree "rebase-many" "$(gettext "Please commit or stash them.")"

head_ref=$(git symbolic-ref -q HEAD)
if test -z "$head_ref"
then
	die "\
You are on a detached HEAD.
Check out the branch you want to rebase."
fi
branch=${head_ref#refs/heads/}
if test "$branch" = "$head_ref"
then
	die "\
HEAD is not under refs/heads/: $head_ref

The 'upstream' feature of Git only operates on refs/heads/.
"
fi

rebase_many_full "$(get_upstream "$branch")" "$branch"

git checkout --quiet "$branch"

# These follow the style in Git upstream.
#
# Local Variables:
# sh-indentation: 8
# sh-basic-offset: 8
# sh-indent-for-case-label: 0
# sh-indent-for-case-alt: +
# indent-tabs-mode: t
# End:
